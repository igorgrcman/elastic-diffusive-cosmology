#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
EDC Mercury Precession â€” Bridge Validation (v17.49.2)
Method: Difference-of-runs (Bridge - Newton)

Epistemic status:
- BASELINE: Newtonian limit + Schwarzschild 1PN correction term.
- IDENTIFIED: Interpretation via plenum "river" bridge (PG mapping).
- DERIVED: Anomalous perihelion advance via difference-of-runs.
"""

import argparse
import math
import numpy as np
import matplotlib.pyplot as plt

# --- CONSTANTS (CODATA 2018) ---
G = 6.67430e-11
c = 299792458.0
M_SUN = 1.98847e30

# --- MERCURY PARAMETERS ---
A_MERCURY = 5.7909227e10   # Semi-major axis (m)
E_MERCURY = 0.205630       # Eccentricity
T_DAYS = 87.9691           # Orbital period (days)

def orbit_rhs(u, L, mode):
    """
    Binet Equation: u'' + u = f(u)
    Newton: f(u) = GM/L^2
    Bridge (EDC Inflow): f(u) = GM/L^2 + 3GM/c^2 * u^2
    """
    base = G * M_SUN / (L**2)
    if mode == "newton":
        return base
    if mode == "bridge":
        return base + (3.0 * G * M_SUN / c**2) * (u**2)
    return base

def integrate_orbit(dphi, n_orbits, mode):
    # Angular momentum L (Newtonian approximation is sufficient for delta)
    L = math.sqrt(G * M_SUN * A_MERCURY * (1.0 - E_MERCURY**2))
    
    # Start at perihelion
    r_peri = A_MERCURY * (1.0 - E_MERCURY)
    u0 = 1.0 / r_peri
    
    steps_per_orbit = int((2.0 * math.pi) / dphi)
    N = steps_per_orbit * n_orbits
    
    phis = np.linspace(0.0, N * dphi, N + 1)
    us = np.zeros(N + 1)
    us[0] = u0
    
    # Verlet-style integration for stability
    u_prev = u0
    u_curr = u0
    
    for i in range(1, N + 1):
        # Binet: u'' = f(u) - u
        u_dd = orbit_rhs(u_curr, L, mode) - u_curr
        u_next = 2.0 * u_curr - u_prev + (dphi**2) * u_dd
        u_prev, u_curr = u_curr, u_next
        us[i] = u_curr
        
    return phis, us

def detect_perihelia(phis, us, discard_fraction=0.1):
    """
    Finds peaks of u(phi) using zero-crossing of the derivative 
    and quadratic interpolation for sub-step precision.
    """
    start_idx = int(len(us) * discard_fraction)
    peri_angles = []
    
    # Look for local maxima of u
    for i in range(start_idx, len(us) - 2):
        if us[i+1] > us[i] and us[i+1] >= us[i+2]:
            # Quadratic interpolation for the peak
            y1, y2, y3 = us[i], us[i+1], us[i+2]
            x1, x2, x3 = phis[i], phis[i+1], phis[i+2]
            
            denom = (x1-x2)*(x1-x3)*(x2-x3)
            if abs(denom) > 1e-25:
                A = (x3*(y2-y1) + x2*(y1-y3) + x1*(y3-y2)) / denom
                B = (x3**2*(y1-y2) + x2**2*(y3-y1) + x1**2*(y2-y3)) / denom
                phi_peak = -B / (2*A)
                peri_angles.append(phi_peak)
                
    return peri_angles

def calculate_precession(mode, dphi, n_orbits):
    phis, us = integrate_orbit(dphi, n_orbits, mode)
    peri_angles = detect_perihelia(phis, us)
    
    if len(peri_angles) < 2:
        return 0.0, 0
    
    # Average change in angle per orbit
    deltas = [peri_angles[i+1] - peri_angles[i] for i in range(len(peri_angles)-1)]
    avg_delta_phi = np.mean(deltas)
    
    # Convert to arcsec/century
    advance_per_orbit = avg_delta_phi - 2.0 * math.pi
    orbits_per_century = (365.25 * 100.0) / T_DAYS
    arcsec_per_century = advance_per_orbit * (180.0/math.pi * 3600.0) * orbits_per_century
    
    return arcsec_per_century, len(peri_angles)

def main():
    parser = argparse.ArgumentParser(description="EDC Mercury Precession Bridge Validation")
    parser.add_argument("--dphi", type=float, default=1e-4)
    parser.add_argument("--orbits", type=int, default=100)
    parser.add_argument("--out", type=str, default=None)
    args = parser.parse_args()

    print("="*60)
    print(f"EDC MERCURY PRECESSION BRIDGE (v17.49.2)")
    print("="*60)
    
    # Run Newton
    newton_val, n_n = calculate_precession("newton", args.dphi, args.orbits)
    print(f"[NEWTON] Orbits: {args.orbits}, Perihelia: {n_n}, Shift: {newton_val:.6f} arcsec/cy")
    
    # Run Bridge
    bridge_val, n_b = calculate_precession("bridge", args.dphi, args.orbits)
    print(f"[BRIDGE] Orbits: {args.orbits}, Perihelia: {n_b}, Shift: {bridge_val:.6f} arcsec/cy")
    
    # Difference of runs
    anomaly = bridge_val - newton_val
    print("-" * 60)
    print(f"ANOMALY (BRIDGE - NEWTON): {anomaly:.6f} arcsec/century")
    print("="*60)

    if args.out:
        # Generate a quick plot of the first two orbits
        ph, u_n = integrate_orbit(args.dphi, 2, "newton")
        _, u_b = integrate_orbit(args.dphi, 2, "bridge")
        plt.figure(figsize=(10,6))
        plt.plot(ph, u_n, label="Newtonian Baseline", linestyle='--')
        plt.plot(ph, u_b, label="EDC Bridge (1PN)")
        plt.title("Mercury Orbital u(phi) - Initial Divergence")
        plt.xlabel("phi (rad)")
        plt.ylabel("u = 1/r (1/m)")
        plt.legend()
        plt.savefig(args.out, dpi=200)
        print(f"Plot saved to: {args.out}")

if __name__ == "__main__":
    main()
