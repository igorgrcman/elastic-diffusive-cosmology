#!/usr/bin/env python3
"""
================================================================================
REPRO SCRIPT: sin²θ_W from Z₆ Subgroup Counting
================================================================================

Classification: REPRO (Physics-supporting)

Supports claims:
- E-CH11-Der-005: sin²θ_W = 1/4 from Z₆ subgroup counting
- E-CH11-Der-013: sin²θ_W(μ_lattice) = |Z₂|/(|Z₂|+|Z₆|) = 1/4

References:
- src/Z6_content_full.tex, Theorem 4 (thm:weinberg_angle)
- src/sections/11_gf_derivation.tex, Eq. (eq:ch11_sin2_input)

What it proves:
- Algebraic identity |Z₂|/(|Z₂|+|Z₆|) = 2/8 = 1/4 is mathematically correct
- Z₆ subgroup structure {Z₁, Z₂, Z₃} is valid
- Coupling ratio g'²/g² = |Z₂|/|Z₆| = 1/3

Output:
- repro/output/sin2_z6_verify.json

Determinism: Pure algebraic calculation, no randomness.
================================================================================
"""

import json
import sys
from pathlib import Path
from datetime import datetime

# Configuration
SCRIPT_NAME = "repro_sin2_z6_verify.py"
SCRIPT_DIR = Path(__file__).parent
OUTPUT_DIR = SCRIPT_DIR.parent / "output"

# Z₆ subgroup structure (mathematical fact)
Z6_ORDER = 6  # |Z₆| = 6
Z2_ORDER = 2  # |Z₂| = 2 (the unique order-2 subgroup of Z₆)
Z3_ORDER = 3  # |Z₃| = 3 (the unique order-3 subgroup of Z₆)

# Baseline comparison
PDG_SIN2_MZ = 0.23122  # PDG 2024 value at M_Z


def verify_z6_subgroup_structure():
    """Verify the Z₆ subgroup structure used in the derivation."""
    # Z₆ = {0, 1, 2, 3, 4, 5} under addition mod 6
    z6_elements = set(range(6))

    # Subgroups of Z₆
    z1 = {0}  # Trivial subgroup
    z2 = {0, 3}  # Order-2 subgroup (generated by 3)
    z3 = {0, 2, 4}  # Order-3 subgroup (generated by 2)

    # Verify they are indeed subgroups (closed under addition mod 6)
    def is_subgroup(S, n=6):
        for a in S:
            for b in S:
                if (a + b) % n not in S:
                    return False
        return True

    z2_valid = is_subgroup(z2)
    z3_valid = is_subgroup(z3)

    return {
        "z6_elements": list(z6_elements),
        "z2_elements": list(z2),
        "z3_elements": list(z3),
        "z2_is_subgroup": z2_valid,
        "z3_is_subgroup": z3_valid,
        "verification": z2_valid and z3_valid
    }


def compute_coupling_ratio():
    """Compute the coupling ratio g'²/g² from Z₆ partition."""
    # From EDC: g'² ∝ |Z₂|, g² ∝ |Z₆|
    ratio = Z2_ORDER / Z6_ORDER
    expected = 1/3
    verification = abs(ratio - expected) < 1e-10

    return {
        "g_prime_squared_prop": Z2_ORDER,
        "g_squared_prop": Z6_ORDER,
        "ratio": ratio,
        "expected": expected,
        "verification": verification
    }


def compute_sin2_theta_w(coupling_ratio):
    """Compute sin²θ_W from the standard electroweak formula."""
    # sin²θ_W = g'² / (g² + g'²) = r / (1 + r)
    r = coupling_ratio
    sin2_theta_w = r / (1 + r)
    expected = 0.25
    verification = abs(sin2_theta_w - expected) < 1e-10

    return {
        "formula": "g'²/(g² + g'²)",
        "coupling_ratio": r,
        "sin2_theta_w": sin2_theta_w,
        "expected": expected,
        "verification": verification
    }


def compute_alternative_formula():
    """Verify the alternative formula |Z₂|/(|Z₂|+|Z₆|)."""
    numerator = Z2_ORDER
    denominator = Z2_ORDER + Z6_ORDER
    sin2_theta_w = numerator / denominator
    expected = 0.25
    verification = abs(sin2_theta_w - expected) < 1e-10

    return {
        "formula": "|Z₂|/(|Z₂|+|Z₆|)",
        "numerator": numerator,
        "denominator": denominator,
        "sin2_theta_w": sin2_theta_w,
        "expected": expected,
        "verification": verification
    }


def compare_with_experiment(sin2_bare):
    """Compare with experimental value."""
    deviation_percent = (sin2_bare - PDG_SIN2_MZ) / PDG_SIN2_MZ * 100

    return {
        "sin2_bare": sin2_bare,
        "pdg_mz": PDG_SIN2_MZ,
        "deviation_percent": deviation_percent,
        "note": "Bare value differs from M_Z value; RG running needed for comparison"
    }


def main():
    """Run all verifications and output results."""
    results = {
        "script": SCRIPT_NAME,
        "classification": "REPRO",
        "timestamp": datetime.now().isoformat(),
        "supports_claims": ["E-CH11-Der-005", "E-CH11-Der-013"],
        "inputs": {
            "Z6_ORDER": Z6_ORDER,
            "Z2_ORDER": Z2_ORDER,
            "Z3_ORDER": Z3_ORDER
        },
        "subgroup_verification": verify_z6_subgroup_structure(),
        "coupling_ratio": compute_coupling_ratio(),
        "sin2_method1": compute_sin2_theta_w(Z2_ORDER / Z6_ORDER),
        "sin2_method2": compute_alternative_formula(),
        "experimental_comparison": compare_with_experiment(0.25)
    }

    # Overall verification
    all_pass = (
        results["subgroup_verification"]["verification"] and
        results["coupling_ratio"]["verification"] and
        results["sin2_method1"]["verification"] and
        results["sin2_method2"]["verification"]
    )

    results["overall_verification"] = "PASS" if all_pass else "FAIL"

    # Write output
    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)
    output_file = OUTPUT_DIR / "sin2_z6_verify.json"

    with open(output_file, 'w') as f:
        json.dump(results, f, indent=2)

    # Print summary
    print(f"REPRO: {SCRIPT_NAME}")
    print(f"Claims: E-CH11-Der-005, E-CH11-Der-013")
    print(f"sin²θ_W = {results['sin2_method1']['sin2_theta_w']} (expected: 0.25)")
    print(f"Verification: {results['overall_verification']}")
    print(f"Output: {output_file}")

    return 0 if all_pass else 1


if __name__ == '__main__':
    sys.exit(main())
